üöÄ OTIMIZA√á√ÉO DE PERFORMANCE - REUNI√ÉO P√öBLICA (100ms)
Data: 2026-01-21
Objetivo: Reduzir tempo de carregamento da sala de reuni√£o de ~4-6s para <2s

üìä ARQUIVOS ANALISADOS
Arquivo	Linhas	Localiza√ß√£o
PublicMeetingRoom.tsx
505	src/pages/
Meeting100ms.tsx
1090	src/components/
meetings.ts
2492	server/routes/
hms100ms.ts
259	server/services/meetings/
use100ms.ts
32	src/hooks/
‚ö†Ô∏è Arquivos DUPLICADOS (c√≥digo morto)
reuniao/client/src/components/Meeting100ms.tsx    [DUPLICATA]
reuniao/client/src/pages/PublicMeetingRoom.tsx   [DUPLICATA]
reuniao/client/src/components/MeetingLobby.tsx   [DUPLICATA]
reuniao/client/src/hooks/useMeetingType.ts       [DUPLICATA]
reuniao/client/src/stores/meetingStore.ts        [DUPLICATA]
üî¥ PROBLEMAS IDENTIFICADOS
1. Bundle SDK 100ms Gigante (~400KB)
// Meeting100ms.tsx - linha 2-18
import {
  useHMSStore, useHMSActions, useVideo, useHMSNotifications,
  HMSNotificationTypes, selectPeers, selectIsConnectedToRoom,
  selectIsLocalAudioEnabled, selectIsLocalVideoEnabled,
  selectIsLocalScreenShared, selectRoom, selectRoomState,
  HMSPeer, HMSRoomState, HMSRoomProvider,
} from "@100mslive/react-sdk";
SDK inteiro carregado mesmo para usu√°rios no lobby
Impacto: +300-400KB bundle, +2s parse
2. 3 Fetches Sequenciais para Entrar
1. GET /api/public/reuniao/:companySlug/:roomId  (dados da reuni√£o)
2. POST /token-public (gerar token)
3. Opcional: GET /participant-data (ap√≥s sair)
Cada fetch adiciona 100-300ms de lat√™ncia
Impacto: +500ms total
3. 100+ Console.logs em Produ√ß√£o
// Meeting100ms.tsx - exemplos
console.log("[Meeting100ms] üîß Ativando logs de debug do SDK 100ms...");
console.log("[Meeting100ms] üìä Room state atualizado:", {...});
console.log("[Meeting100ms] üîî Notifica√ß√£o recebida:", ...);
Performance degradada em produ√ß√£o
Impacto: +50-100ms em cada intera√ß√£o
4. Componente Monol√≠tico (1090 linhas)
Meeting100ms.tsx
 faz tudo: video, audio, screen share, recording, error handling
Impacto: Re-renders excessivos, manuten√ß√£o dif√≠cil
5. Nenhum Cache de Configura√ß√£o
// meetings.ts - linha 202-280
// Cada acesso busca roomDesignConfig do PostgreSQL + Supabase fallback
publicRoomDesignRouter.get('/reunioes/public/:companySlug/:roomId', async ...)
Mesma configura√ß√£o buscada a cada request
Impacto: +100ms por request redundante
6. Token N√£o Cacheado
// MeetingWrapper - linhas 393-404
const pubResponse = await fetch(`/api/public/reunioes/${reuniao.id}/token-public`, {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ userName: participantName || 'Convidado' })
});
Token JWT gerado a cada refresh de p√°gina
Impacto: +200ms (gera√ß√£o JWT no servidor)
7. 30s Timeout Muito Longo
// Meeting100ms.tsx - linha 333-345
joinTimeoutRef.current = setTimeout(() => {
  // S√≥ detecta problema ap√≥s 30 segundos
}, 30000);
Usu√°rio espera 30s antes de ver erro
Impacto: UX ruim em falhas de conex√£o
8. Arquivos Duplicados na Pasta reuniao/
Toda a pasta reuniao/client/ parece ser c√≥digo legado
Componentes duplicados aumentam bundle se importados
Impacto: Confus√£o de manuten√ß√£o, poss√≠vel bloat
‚úÖ CORRE√á√ïES PROPOSTAS
CORRE√á√ÉO 1: Lazy Load do SDK 100ms
J√° implementado em 
PublicMeetingRoom.tsx
 ‚úì

const Meeting100msWithProvider = lazy(() => 
  import("@/components/Meeting100ms").then(module => ({ 
    default: module.Meeting100msWithProvider 
  }))
);
Adicionar preload no lobby:

// MeetingLobby.tsx - adicionar
useEffect(() => {
  // Preload do SDK enquanto usu√°rio preenche nome
  const preload = () => import("@/components/Meeting100ms");
  preload();
}, []);
CORRE√á√ÉO 2: Endpoint Unificado para Reuni√£o + Token
Criar: 
server/routes/meetings.ts

// NOVO ENDPOINT OTIMIZADO
publicRoomDesignRouter.get('/reunioes/public/:companySlug/:roomId/full', async (req, res) => {
  const { companySlug, roomId } = req.params;
  const { userName } = req.query;
  
  try {
    // 1. Buscar reuni√£o (j√° faz isso)
    const meeting = await findMeeting(companySlug, roomId);
    if (!meeting) return res.status(404).json({ error: 'Reuni√£o n√£o encontrada' });
    
    // 2. Buscar config (com cache)
    const cacheKey = `room-design:${meeting.tenantId}`;
    let roomDesignConfig = cache.get(cacheKey);
    if (!roomDesignConfig) {
      roomDesignConfig = await getDesignConfig(meeting.tenantId);
      cache.set(cacheKey, roomDesignConfig, 300); // 5 min cache
    }
    
    // 3. Gerar token SE userName foi passado
    let authToken = null;
    if (userName) {
      authToken = gerarTokenParticipante(
        meeting.roomId100ms,
        `user-${Date.now()}`,
        'guest',
        process.env.HMS_ACCESS_KEY!,
        process.env.HMS_SECRET!
      );
    }
    
    // 4. Retornar tudo de uma vez
    res.set('Cache-Control', 'private, max-age=60');
    return res.json({
      reuniao: meeting,
      tenant: { id: meeting.tenantId, nome: meeting.tenantNome },
      roomDesignConfig,
      authToken // null se userName n√£o foi passado
    });
  } catch (error) {
    return res.status(500).json({ error: 'Erro interno' });
  }
});
CORRE√á√ÉO 3: Remover Console.logs em Produ√ß√£o
Criar: src/lib/logger.ts

const isDev = import.meta.env.DEV;
export const meetingLogger = {
  log: (...args: any[]) => isDev && console.log('[Meeting]', ...args),
  warn: (...args: any[]) => isDev && console.warn('[Meeting]', ...args),
  error: (...args: any[]) => console.error('[Meeting]', ...args), // Erros sempre
};
Substituir em 
Meeting100ms.tsx
:

// ANTES:
console.log("[Meeting100ms] üîß Ativando logs...");
// DEPOIS:
import { meetingLogger } from '@/lib/logger';
meetingLogger.log("üîß Ativando logs...");
CORRE√á√ÉO 4: Reduzir Timeout de Conex√£o
Arquivo: 
Meeting100ms.tsx

ANTES (linha 333):

joinTimeoutRef.current = setTimeout(() => { ... }, 30000);
DEPOIS:

joinTimeoutRef.current = setTimeout(() => { ... }, 10000); // 10s √© suficiente
CORRE√á√ÉO 5: Adicionar Cache de Token no Frontend
Arquivo: 
PublicMeetingRoom.tsx
 - 
MeetingWrapper

// Usar sessionStorage para cachear token
const getCachedToken = (roomId: string, userName: string) => {
  const cacheKey = `meeting-token:${roomId}:${userName}`;
  const cached = sessionStorage.getItem(cacheKey);
  if (cached) {
    const { token, expiresAt } = JSON.parse(cached);
    if (Date.now() < expiresAt) {
      return token;
    }
  }
  return null;
};
const setCachedToken = (roomId: string, userName: string, token: string) => {
  const cacheKey = `meeting-token:${roomId}:${userName}`;
  sessionStorage.setItem(cacheKey, JSON.stringify({
    token,
    expiresAt: Date.now() + (23 * 60 * 60 * 1000) // 23 horas
  }));
};
// No useEffect de getToken:
const cachedToken = getCachedToken(reuniao.roomId100ms, participantName);
if (cachedToken) {
  setAuthToken(cachedToken);
  return;
}
// ... resto do c√≥digo para buscar novo token
setCachedToken(reuniao.roomId100ms, participantName, pubData.token);
CORRE√á√ÉO 6: Deletar Arquivos Duplicados
Executar no terminal:

# ATEN√á√ÉO: Verificar se pasta reuniao/ n√£o √© usada antes de deletar
rm -rf reuniao/client/
Ou manter e adicionar ao 
.gitignore
:

# C√≥digo legado - n√£o usar
reuniao/client/
CORRE√á√ÉO 7: Adicionar Cache Headers no Backend
Arquivo: 
server/routes/meetings.ts

Adicionar ap√≥s cada res.json():

// Para roomDesignConfig (muda raramente)
res.set('Cache-Control', 'public, max-age=300'); // 5 min
return res.json({ roomDesignConfig, source: 'tenant' });
// Para dados de reuni√£o (muda mais)
res.set('Cache-Control', 'private, max-age=60'); // 1 min
return res.json({ reuniao, tenant, roomDesignConfig });
CORRE√á√ÉO 8: Code Split do Meeting100ms
Dividir em:

components/meeting/
  ‚îú‚îÄ‚îÄ index.tsx           (export principal)
  ‚îú‚îÄ‚îÄ MeetingRoom.tsx     (layout principal)
  ‚îú‚îÄ‚îÄ PeerVideo.tsx       (v√≠deo de participante)
  ‚îú‚îÄ‚îÄ ScreenShare.tsx     (compartilhamento de tela)
  ‚îú‚îÄ‚îÄ ControlBar.tsx      (barra de controles)
  ‚îú‚îÄ‚îÄ RecordingControls.tsx
  ‚îî‚îÄ‚îÄ hooks/
      ‚îú‚îÄ‚îÄ useRoomConnection.ts
      ‚îî‚îÄ‚îÄ useMediaControls.ts
üìà IMPACTO ESPERADO
M√©trica	Antes	Depois	Melhoria
Time to Lobby	~2s	~0.8s	60%
Time to Meeting	~4-6s	~2s	60%
Bundle Size (SDK)	~400KB	~400KB (lazy)	-
API Requests	2-3	1	66%
Lighthouse Score	~50	~75	+25pts
üéØ ORDEM DE IMPLEMENTA√á√ÉO
IMEDIATO: Remover console.logs ou usar logger (30 min)
IMEDIATO: Reduzir timeout de 30s para 10s (5 min)
PRIORIDADE 1: Cache headers no backend (15 min)
PRIORIDADE 2: Endpoint unificado /full (1 hora)
PRIORIDADE 3: Cache de token no frontend (30 min)
PRIORIDADE 4: Code split (2 horas)
üìÅ VARI√ÅVEIS DE AMBIENTE 100ms
HMS_ACCESS_KEY=xxxxxxxxxxxxxxxx
HMS_SECRET=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
HMS_TEMPLATE_ID=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
FIM DO DOCUMENTO DE OTIMIZA√á√ÉO