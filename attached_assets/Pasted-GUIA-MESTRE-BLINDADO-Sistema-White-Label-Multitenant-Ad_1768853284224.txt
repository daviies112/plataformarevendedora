GUIA MESTRE BLINDADO: Sistema White-Label Multitenant (Admin + Revendedora)
PARA O USUÃRIO: Este documento foi refinado para ser "Ã  prova de erros". Ele contÃ©m nÃ£o apenas a teoria, mas os cÃ³digos exatos de configuraÃ§Ã£o e uma estratÃ©gia de Prompts Sequenciais para vocÃª enviar ao Replit.

ðŸ—ºï¸ EstratÃ©gia de ExecuÃ§Ã£o (O Segredo do Sucesso)
NÃ£o peÃ§a para o Replit "fazer tudo de uma vez". Use a estratÃ©gia de 4 Prompts. Envie um por um e espere ele terminar.
ðŸ“‹ Prompt 1: ReestruturaÃ§Ã£o Monorepo
(Copie e cole isso primeiro)
"Atue como Arquiteto de Software SÃªnior. Sua tarefa Ã© transformar o projeto atual em um Monorepo usando Turborepo e npm workspaces.
Crie a pasta packages/.
Mova o cÃ³digo atual (admin) para packages/admin.
Crie um novo app React Vite limpo em packages/revendedora.
Crie um pacote compartilhado em packages/shared.
Configure o 
package.json raiz e o turbo.json conforme as especificaÃ§Ãµes abaixo.
Certifique-se de que o backend (server/) continue na raiz mas acessÃ­vel.
EspecificaÃ§Ã£o do package.json raiz:
{
 "name": "plataforma-multitenant",
 "private": true,
 "workspaces": [
   "packages/*"
 ],
 "scripts": {
   "dev": "turbo run dev",
   "build": "turbo run build",
   "start": "node server/index.ts"
 },
 "devDependencies": {
   "turbo": "latest"
 }
}
NÃ£o apague nenhum cÃ³digo funcional do admin, apenas mova."

ðŸ“‹ Prompt 2: Core Compartilhado (Auth & Theme)
(Envie este apÃ³s o Prompt 1 terminar)
"Agora vamos configurar o pacote packages/shared. Preciso que vocÃª crie o nÃºcleo da nossa lÃ³gica multitenant.
Em packages/shared/src, crie:
contexts/AuthContext.tsx: Deve aceitar um userType ('admin' | 'reseller') e conectar no endpoint /api/auth/login.
contexts/ThemeContext.tsx: Deve ler a config do tenant e prover cores/logo.
Requisito CrÃ­tico do AuthContext: O login deve retornar { token, tenantConfig, supabaseCredentials }. Use as credenciais retornadas para instanciar o cliente Supabase dinamicamente, nÃ£o use variÃ¡veis de ambiente fixas.
Requisito CrÃ­tico do ThemeContext: Deve injetar CSS variables no :root do documento: document.documentElement.style.setProperty('--primary', theme.colors.primary);"

ðŸ“‹ Prompt 3: Backend Master
(Envie este apÃ³s o Prompt 2)
"Vamos atualizar o Backend (server/) para suportar a arquitetura Master.
Crie/Atualize o schema SQL no Supabase Principal com as tabelas admins (com configuraÃ§Ãµes de app) e resellers.
Crie a rota POST /api/auth/login-unified que:
Recebe { email, password, appSlug, userType }.
Se userType === 'admin', busca na tabela admins.
Se userType === 'reseller', busca na tabela resellers E busca os dados do admin relacionado (cores, supbase_url).
Retorna o JSON unificado com credenciais do Supabase dedicado.
Crie a rota GET /api/public-config/:slug para o app mobile saber as cores antes do login."

ðŸ“‹ Prompt 4: AdaptaÃ§Ã£o dos Apps
(Envie este por Ãºltimo)
"Hora de conectar as pontas.
No packages/admin:
Envolva o App com AuthProvider (userType='admin') e ThemeProvider.
Crie a pÃ¡gina ConfiguracoesApp para editar logo/cores na tabela admins.
No packages/revendedora:
Use o AuthProvider (userType='reseller').
Crie uma tela de Login que verifica o subdomÃ­nio ou slug para carregar o tema antes de logar.
Garanta que ele usa o cliente Supabase dinÃ¢mico (do contexto) para todas as chamadas de dados."

ðŸ› ï¸ EspecificaÃ§Ãµes TÃ©cnicas (Para a IA consultar)
1. Estrutura de Pastas Esperada
/
â”œâ”€â”€ package.json (Workspaces configurado)
â”œâ”€â”€ turbo.json
â”œâ”€â”€ server/
â”‚   â””â”€â”€ (CÃ³digo backend existente + novas rotas auth)
â””â”€â”€ packages/
   â”œâ”€â”€ admin/ (CÃ³digo antigo movido)
   â”‚   â”œâ”€â”€ package.json (name: "@plataforma/admin")
   â”‚   â””â”€â”€ vite.config.ts
   â”œâ”€â”€ revendedora/ (Novo app)
   â”‚   â”œâ”€â”€ package.json (name: "@plataforma/revendedora")
   â”‚   â”œâ”€â”€ vite.config.ts
   â”‚   â””â”€â”€ src/App.tsx
   â””â”€â”€ shared/ (Libs comuns)
       â”œâ”€â”€ package.json (name: "@plataforma/shared")
       â”œâ”€â”€ src/contexts/
       â””â”€â”€ src/hooks/
2. CÃ³digo Vital: Auth Unificado (server)
Este Ã© o coraÃ§Ã£o da lÃ³gica. A IA deve implementar algo prÃ³ximo a isso:
// server/routes/auth-unified.ts
router.post('/login-unified', async (req, res) => {
 const { email, password, userType, slug } = req.body;
 let tenantConfig;
 let user;
 if (userType === 'admin') {
   // Busca no Supabase MASTER
   user = await findAdmin(email, password);
   if (!user) return authError();
  
   tenantConfig = {
     supabaseUrl: user.supabase_url,
     supabaseKey: user.supabase_anon_key,
     theme: { primary: user.primary_color, logo: user.logo_url }
   };
 }
  else if (userType === 'reseller') {
   // 1. Busca revendedora
   const reseller = await findReseller(email, password);
   if (!reseller) return authError();
  
   // 2. Busca o admin (dono) para pegar as configs
   const admin = await findAdminById(reseller.admin_id);
  
   tenantConfig = {
     supabaseUrl: admin.supabase_url, // USA O SUPABASE DO ADMIN!
     supabaseKey: admin.supabase_anon_key,
     theme: { primary: admin.primary_color, logo: admin.logo_url } // USA O TEMA DO ADMIN!
   };
   user = reseller;
 }
 // Gera token com payload contendo as configs necessÃ¡rias para o frontend
 const token = signJwt({ ...user, tenantConfig });
 res.json({ token, user, tenantConfig });
});
3. CÃ³digo Vital: Mobile Config (capacitor.config.json)
InstruÃ§Ã£o para quando vocÃª for gerar os APKS. Cada cliente terÃ¡ um arquivo desse na hora do build.
{
 "appId": "com.cliente.app",
 "appName": "Nome do Cliente",
 "webDir": "dist",
 "server": {
   "url": "https://suaplataforma.com/revenda?slug=cliente_x",
   "allowNavigation": ["*"]
 }
}

âœ… Checklist de Sucesso
Antes de considerar pronto, verifique:
 O Admin consegue logar e vÃª suas cores?
 A Revendedora consegue logar e vÃª as cores do Admin dela?
 A Revendedora vÃª os produtos/dados do Admin dela (Supabase conectado certo)?
 O arquivo packages/shared estÃ¡ sendo usado pelos dois apps?
Entregue este documento ao Replit e use os Prompts Sequenciais para garantir que ele nÃ£o se perca na complexidade.

